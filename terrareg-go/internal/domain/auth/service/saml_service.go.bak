package service

import (
	"context"
	"encoding/base64"
	"encoding/xml"
	"fmt"
	"net/url"
	"strings"
	"time"

	"github.com/crewjam/saml"
	"github.com/matthewjohn/terrareg/terrareg-go/internal/infrastructure/config"
)

// SAMLService handles SAML 2.0 authentication
type SAMLService struct {
	config         *config.InfrastructureConfig
	serviceProvider *saml.ServiceProvider
	idpMetadata    *saml.EntityDescriptor
}

// SAMLUserInfo represents user information extracted from SAML assertions
type SAMLUserInfo struct {
	NameID       string            `json:"name_id"`
	NameIDFormat string            `json:"name_id_format"`
	Subject      string            `json:"subject"`
	Email        string            `json:"email"`
	Name         string            `json:"name"`
	FirstName    string            `json:"first_name"`
	LastName     string            `json:"last_name"`
	Username     string            `json:"username"`
	Groups       []string          `json:"groups"`
	Attributes   map[string]string `json:"attributes"`
	SessionIndex string            `json:"session_index"`
	RawAssertion string            `json:"raw_assertion"`
}

// SAMLAuthRequest represents a SAML authentication request
type SAMLAuthRequest struct {
	ID           string    `json:"id"`
	Destination  string    `json:"destination"`
	RelayState   string    `json:"relay_state"`
	SAMLRequest  string    `json:"saml_request"`
	CreatedAt    time.Time `json:"created_at"`
	ExpiresAt    time.Time `json:"expires_at"`
}

// NewSAMLService creates a new SAML service
func NewSAMLService(config *config.InfrastructureConfig) (*SAMLService, error) {
	if !isSAMLConfigured(config) {
		return nil, fmt.Errorf("SAML is not configured")
	}

	// Create service provider configuration
	serviceProvider := &saml.ServiceProvider{
		EntityID:          config.SAML2EntityID,
		Key:               getSAMLPrivateKey(config),
		Certificate:       getSAMLCertificate(config),
		MetadataURL:       getSAMLMetadataURL(config),
		AcsURL:            getSAMLACSURL(config),
		SloURL:            getSAMLSLOURL(config),
		IDPMetadata:       getSAMLIDPMetadata(config),
		AllowIDPInitiated: true,
	}

	// Parse IDP metadata
	var idpMetadata *saml.EntityDescriptor
	if config.SAML2IDPMetadataURL != "" {
		metadata, err := fetchIDPMetadata(config.SAML2IDPMetadataURL)
		if err != nil {
			return nil, fmt.Errorf("failed to fetch IDP metadata: %w", err)
		}
		idpMetadata = metadata
	}

	return &SAMLService{
		config:          config,
		serviceProvider: serviceProvider,
		idpMetadata:     idpMetadata,
	}, nil
}

// CreateAuthRequest creates a SAML authentication request
func (s *SAMLService) CreateAuthRequest(ctx context.Context, relayState string) (*SAMLAuthRequest, error) {
	// Create authentication request
	authRequest := &saml.AuthnRequest{
		ID:           s.generateRequestID(),
		Destination:  s.getIDPSSOURL(),
		Issuer:       &saml.Issuer{Value: s.config.SAML2EntityID},
		IssueInstant: saml.TimeNow(),
		NameIDPolicy: &saml.NameIDPolicy{
			Format: saml.NameIDFormatTransient,
		},
		RequestedAuthnContext: &saml.RequestedAuthnContext{
			AuthnContextClassRef: saml.AuthnContextClassRefs{
				saml.AuthnContextClassRefPasswordProtectedTransport,
			},
		},
		ProtocolBinding: saml.ProtocolBindingHTTPPost,
		AssertionConsumerServiceURL: s.getSAMLACSURL(),
	}

	// Sign the request if certificates are available
	if s.serviceProvider.Key != nil && s.serviceProvider.Certificate != nil {
		authRequest.Signature = &saml.Signature{
			SigningMethod: &saml.SigningMethod{
				Algorithm: saml.RSASHA256SignatureMethod,
			},
		}
	}

	// Marshal the request
	requestXML, err := xml.Marshal(authRequest)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal SAML request: %w", err)
	}

	// Encode the request
	encodedRequest := base64.StdEncoding.EncodeToString(requestXML)

	return &SAMLAuthRequest{
		ID:          authRequest.ID,
		Destination: authRequest.Destination,
		RelayState:  relayState,
		SAMLRequest: encodedRequest,
		CreatedAt:   time.Now(),
		ExpiresAt:   time.Now().Add(10 * time.Minute),
	}, nil
}

// ProcessResponse processes a SAML response from the IdP
func (s *SAMLService) ProcessResponse(ctx context.Context, samlResponse, relayState string) (*SAMLUserInfo, error) {
	if samlResponse == "" {
		return nil, fmt.Errorf("SAML response cannot be empty")
	}

	// Decode the SAML response
	decodedResponse, err := base64.StdEncoding.DecodeString(samlResponse)
	if err != nil {
		return nil, fmt.Errorf("failed to decode SAML response: %w", err)
	}

	// Parse the SAML response
	var response saml.Response
	if err := xml.Unmarshal(decodedResponse, &response); err != nil {
		return nil, fmt.Errorf("failed to parse SAML response: %w", err)
	}

	// Validate the response
	if err := s.validateResponse(&response); err != nil {
		return nil, fmt.Errorf("SAML response validation failed: %w", err)
	}

	// Extract user information
	userInfo := s.extractUserInfo(&response)

	return userInfo, nil
}

// GetMetadata generates SAML metadata for the service provider
func (s *SAMLService) GetMetadata(ctx context.Context) (string, error) {
	metadata := s.serviceProvider.Metadata()
	metadataXML, err := xml.MarshalIndent(metadata, "", "  ")
	if err != nil {
		return "", fmt.Errorf("failed to marshal SAML metadata: %w", err)
	}

	return string(metadataXML), nil
}

// validateResponse validates a SAML response
func (s *SAMLService) validateResponse(response *saml.Response) error {
	// Check if response is successful
	if response.Status.StatusCode.Value != saml.StatusSuccess {
		if response.Status.StatusMessage != nil {
			return fmt.Errorf("SAML authentication failed: %s", response.Status.StatusMessage.Value)
		}
		return fmt.Errorf("SAML authentication failed with status: %s", response.Status.StatusCode.Value)
	}

	// Validate assertions
	if len(response.Assertions) == 0 {
		return fmt.Errorf("no assertions found in SAML response")
	}

	assertion := response.Assertions[0]

	// Check subject confirmation
	if assertion.Subject == nil {
		return fmt.Errorf("no subject found in SAML assertion")
	}

	if len(assertion.Subject.SubjectConfirmations) == 0 {
		return fmt.Errorf("no subject confirmations found in SAML assertion")
	}

	// TODO: Add more validation:
	// - Signature verification if certificates are available
	// - Conditions validation (time, audience, etc.)
	// - Subject confirmation validation

	return nil
}

// extractUserInfo extracts user information from SAML assertion
func (s *SAMLService) extractUserInfo(response *saml.Response) *SAMLUserInfo {
	userInfo := &SAMLUserInfo{
		Attributes: make(map[string]string),
	}

	if len(response.Assertions) > 0 {
		assertion := response.Assertions[0]

		// Extract NameID
		if assertion.Subject != nil {
			userInfo.NameID = assertion.Subject.NameID.Value
			if assertion.Subject.NameID.Format != "" {
				userInfo.NameIDFormat = assertion.Subject.NameID.Format
			}
		}

		// Extract attributes
		if assertion.AttributeStatement != nil {
			for _, attribute := range assertion.AttributeStatement.Attributes {
				if len(attribute.Values) > 0 {
					value := attribute.Values[0].Value

					// Handle standard attributes
					switch strings.ToLower(attribute.Name) {
					case "email", "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress":
						userInfo.Email = value
					case "name", "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/name":
						userInfo.Name = value
					case "givenname", "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname":
						userInfo.FirstName = value
					case "surname", "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname":
						userInfo.LastName = value
					case "username", "preferred_username", "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier":
						userInfo.Username = value
					case "groups", "member", "http://schemas.xmlsoap.org/claims/Group":
						userInfo.Groups = attribute.ValuesToStrings()
					default:
						userInfo.Attributes[attribute.Name] = value
					}
				}
			}
		}

		// Extract session index
		if assertion.AuthnStatement != nil && assertion.AuthnStatement.SessionIndex != "" {
			userInfo.SessionIndex = assertion.AuthnStatement.SessionIndex
		}

		// Set username fallback logic
		if userInfo.Username == "" {
			if userInfo.Email != "" {
				userInfo.Username = userInfo.Email
			} else if userInfo.Name != "" {
				userInfo.Username = userInfo.Name
			} else {
				userInfo.Username = userInfo.NameID
			}
		}

		// Set name fallback logic
		if userInfo.Name == "" {
			if userInfo.FirstName != "" && userInfo.LastName != "" {
				userInfo.Name = fmt.Sprintf("%s %s", userInfo.FirstName, userInfo.LastName)
			} else if userInfo.FirstName != "" {
				userInfo.Name = userInfo.FirstName
			} else if userInfo.LastName != "" {
				userInfo.Name = userInfo.LastName
			} else if userInfo.Username != "" {
				userInfo.Name = userInfo.Username
			}
		}
	}

	// Store raw assertion for auditing
	responseXML, _ := xml.Marshal(response)
	userInfo.RawAssertion = string(responseXML)

	return userInfo
}

// generateRequestID generates a unique SAML request ID
func (s *SAMLService) generateRequestID() string {
	return fmt.Sprintf("id_%d", time.Now().UnixNano())
}

// getIDPSSOURL returns the IdP SSO URL
func (s *SAMLService) getIDPSSOURL() string {
	if s.idpMetadata != nil && len(s.idpMetadata.IDPSSODescriptors) > 0 {
		for _, idpsso := range s.idpMetadata.IDPSSODescriptors {
			for _, sso := range idpsso.SingleSignOnServices {
				if sso.Binding == saml.ProtocolBindingHTTPRedirect {
					return sso.Location
				}
			}
		}
	}

	// Fallback to configured metadata URL (might be the SSO URL itself)
	if s.config.SAML2IDPMetadataURL != "" {
		return s.config.SAML2IDPMetadataURL
	}

	return ""
}

// getSAMLACSURL returns the ACS URL for SAML
func (s *SAMLService) getSAMLACSURL() string {
	if s.config.PublicURL != "" {
		baseURL, _ := url.Parse(s.config.PublicURL)
		return fmt.Sprintf("%s/v1/terrareg/auth/saml/acs", baseURL.String())
	}
	return "http://localhost:5000/v1/terrareg/auth/saml/acs"
}

// getSAMLSLOURL returns the SLO URL for SAML
func (s *SAMLService) getSAMLSLOURL() string {
	if s.config.PublicURL != "" {
		baseURL, _ := url.Parse(s.config.PublicURL)
		return fmt.Sprintf("%s/v1/terrareg/auth/saml/slo", baseURL.String())
	}
	return "http://localhost:5000/v1/terrareg/auth/saml/slo"
}

// getSAMLMetadataURL returns the metadata URL for SAML
func (s *SAMLService) getSAMLMetadataURL() *url.URL {
	if s.config.PublicURL != "" {
		metadataURL, _ := url.Parse(s.config.PublicURL)
		metadataURL.Path = "/v1/terrareg/auth/saml/metadata"
		return metadataURL
	}

	metadataURL, _ := url.Parse("http://localhost:5000/v1/terrareg/auth/saml/metadata")
	return metadataURL
}

// Helper functions for configuration

func isSAMLConfigured(config *config.InfrastructureConfig) bool {
	return config != nil &&
		config.SAML2EntityID != "" &&
		config.SAML2IDPMetadataURL != ""
}

func getSAMLPrivateKey(config *config.InfrastructureConfig) interface{} {
	// TODO: Load private key from SAML2PrivateKey configuration
	// For now, return nil (optional)
	return nil
}

func getSAMLCertificate(config *config.InfrastructureConfig) interface{} {
	// TODO: Load certificate from SAML2PublicKey configuration
	// For now, return nil (optional)
	return nil
}

func getSAMLIDPMetadata(config *config.InfrastructureConfig) *saml.EntityDescriptor {
	// TODO: Load and parse IDP metadata from SAML2IDPMetadataURL
	// For now, return nil (metadata will be fetched at runtime)
	return nil
}

func fetchIDPMetadata(metadataURL string) (*saml.EntityDescriptor, error) {
	// TODO: Implement HTTP client to fetch IDP metadata
	// For now, return nil
	return nil, fmt.Errorf("IDP metadata fetching not yet implemented")
}