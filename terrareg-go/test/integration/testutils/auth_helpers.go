package testutils

import (
	"context"
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"testing"
	"time"

	"github.com/stretchr/testify/require"

	"github.com/matthewjohn/terrareg/terrareg-go/internal/application/command/auth"
	"github.com/matthewjohn/terrareg/terrareg-go/internal/domain/auth/service"
	"github.com/matthewjohn/terrareg/terrareg-go/internal/infrastructure/config"
	"github.com/matthewjohn/terrareg/terrareg-go/internal/infrastructure/container"
	"github.com/matthewjohn/terrareg/terrareg-go/internal/infrastructure/persistence/sqldb"
	"github.com/matthewjohn/terrareg/terrareg-go/internal/interfaces/http/middleware"
)

// CreateTestSession creates a test session in the database and returns the session ID
func CreateTestSession(t *testing.T, db *sqldb.Database, username string, isAdmin bool) string {
	// Create a session using the session repository
	// The session ID is generated by the repository
	session := &sqldb.SessionDB{
		ID:     "test-session-" + username,
		Expiry: time.Now().Add(1 * time.Hour),
	}

	// Encode provider source auth data
	providerData := map[string]interface{}{
		"username":   username,
		"is_admin":   isAdmin,
		"auth_type":  "session_password",
		"user_groups": []string{},
	}
	encodedData := sqldb.EncodeBlob(providerData)
	session.ProviderSourceAuth = encodedData

	err := db.DB.Create(session).Error
	require.NoError(t, err)

	return session.ID
}

// CreateTestCookieSessionService creates a test CookieSessionService with proper dependencies
// Returns both the CookieSessionService and the container for testing
func CreateTestCookieSessionService(t *testing.T, db *sqldb.Database) (*service.CookieSessionService, *container.Container) {
	// Create container to get all dependencies
	// This will use the same SECRET_KEY as the rest of the test infrastructure
	cont := CreateTestContainer(t, db)

	// Use the container's services directly to ensure SECRET_KEY consistency
	// The container's CookieService uses the same SECRET_KEY as CreateTestInfraConfig
	cookieSessionService := service.NewCookieSessionService(
		cont.SessionService,
		cont.CookieService,
		cont.SessionRepo,
		cont.InfraConfig,
	)

	return cookieSessionService, cont
}

// CreateTestSessionViaService creates a test session using the CookieSessionService
// This is the preferred method as it properly initializes all session components
func CreateTestSessionViaService(t *testing.T, cookieSessionService *service.CookieSessionService, username string, isAdmin bool) *service.CreateSessionResponse {
	ctx := context.Background()

	req := &service.CreateSessionRequest{
		AuthMethod: "session_password",
		Username:   username,
		IsAdmin:    isAdmin,
		SiteAdmin:  isAdmin,
		UserGroups: []string{},
	}

	resp, err := cookieSessionService.CreateSession(ctx, req)
	require.NoError(t, err)
	require.NotNil(t, resp)
	require.True(t, resp.Authenticated)
	require.Equal(t, username, resp.Username)

	return resp
}

// CreateTestSessionCookie creates an encrypted session cookie for testing
// This is used to simulate an authenticated user in tests
func CreateTestSessionCookie(t *testing.T, cookieService *service.CookieService, sessionID, username string, isAdmin bool) string {
	expiry := time.Now().Add(1 * time.Hour)
	sessionData := &service.SessionData{
		SessionID:  sessionID,
		UserID:     username,
		Username:   username,
		AuthMethod: "session_password",
		IsAdmin:    isAdmin,
		SiteAdmin:  isAdmin,
		UserGroups: []string{},
		Expiry:     &expiry,
	}

	encrypted, err := cookieService.EncryptSession(sessionData)
	require.NoError(t, err)

	return encrypted
}

// CreateAuthenticatedRequestWithCookie creates an HTTP request with an encrypted session cookie
// Note: This is named differently from CreateAuthenticatedRequest in auth_middleware.go to avoid conflicts
func CreateAuthenticatedRequestWithCookie(t *testing.T, method, url string, cookieValue string) *http.Request {
	req := httptest.NewRequest(method, url, nil)

	// Add session cookie to the request
	if cookieValue != "" {
		req.AddCookie(&http.Cookie{
			Name:  "terrareg_session",
			Value: cookieValue,
		})
	}

	return req
}

// CreateAuthenticatedRequestWithSession creates an HTTP request with a valid session cookie
// This combines creating a session and adding it as a cookie to the request
func CreateAuthenticatedRequestWithSession(t *testing.T, db *sqldb.Database, method, url, username string, isAdmin bool) (*http.Request, string) {
	// Create session in database
	sessionID := CreateTestSession(t, db, username, isAdmin)

	// Create cookie service to encrypt session cookie
	cfg := &config.InfrastructureConfig{
		SecretKey:         "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
		SessionCookieName: "terrareg_session",
	}
	cookieService := service.NewCookieService(cfg)

	// Create encrypted cookie value
	expiry := time.Now().Add(1 * time.Hour)
	sessionData := &service.SessionData{
		SessionID:  sessionID,
		UserID:     username,
		Username:   username,
		AuthMethod: "session_password",
		IsAdmin:    isAdmin,
		SiteAdmin:  isAdmin,
		UserGroups: []string{},
		Expiry:     &expiry,
	}

	// Create authentication context with session data
	authCtx := &service.AuthenticationContext{
		SessionData:     sessionData,
		IsAuthenticated: true,
		AuthMethod:      "session_password",
		IsAdmin:         isAdmin,
	}

	// Encrypt session data for cookie
	cookieValue, err := cookieService.EncryptSession(sessionData)
	require.NoError(t, err)

	// Create request with cookie
	req := CreateAuthenticatedRequestWithCookie(t, method, url, cookieValue)

	// Add authentication context to request context
	// This allows handlers to use middleware.GetSessionData()
	req = req.WithContext(middleware.WithAuthenticationContext(req.Context(), authCtx))

	return req, cookieValue
}

// AssertSessionExists verifies that a session exists in the database
func AssertSessionExists(t *testing.T, db *sqldb.Database, sessionID string) {
	var session sqldb.SessionDB
	err := db.DB.Where("id = ?", sessionID).First(&session).Error
	require.NoError(t, err, "Session should exist in database")
	require.Equal(t, sessionID, session.ID)
}

// AssertSessionDoesNotExist verifies that a session does not exist in the database
func AssertSessionDoesNotExist(t *testing.T, db *sqldb.Database, sessionID string) {
	var session sqldb.SessionDB
	err := db.DB.Where("id = ?", sessionID).First(&session).Error
	require.Error(t, err, "Session should not exist in database")
}

// GetSessionFromCookie extracts and decrypts session data from a cookie in the response recorder
func GetSessionFromCookie(t *testing.T, cookieService *service.CookieService, w *httptest.ResponseRecorder) *service.SessionData {
	cookies := w.Result().Cookies()
	require.NotEmpty(t, cookies, "Response should contain session cookie")

	var sessionCookie *http.Cookie
	for _, c := range cookies {
		if c.Name == "terrareg_session" {
			sessionCookie = c
			break
		}
	}
	require.NotNil(t, sessionCookie, "Session cookie should be set")

	sessionData, err := cookieService.DecryptSession(sessionCookie.Value)
	require.NoError(t, err, "Session cookie should be decryptable")

	return sessionData
}

// CreateTestAuthUserGroup creates a test user group for authentication tests
func CreateTestAuthUserGroup(t *testing.T, db *sqldb.Database, name string, siteAdmin bool) sqldb.UserGroupDB {
	userGroup := sqldb.UserGroupDB{
		Name:      name,
		SiteAdmin: siteAdmin,
	}

	err := db.DB.Create(&userGroup).Error
	require.NoError(t, err)

	return userGroup
}

// CreateTestNamespacePermission creates a test namespace permission for a user group
func CreateTestNamespacePermission(t *testing.T, db *sqldb.Database, userGroupID, namespaceID int, permissionType sqldb.UserGroupNamespacePermissionType) sqldb.UserGroupNamespacePermissionDB {
	perm := sqldb.UserGroupNamespacePermissionDB{
		UserGroupID:    userGroupID,
		NamespaceID:    namespaceID,
		PermissionType: permissionType,
	}

	err := db.DB.Create(&perm).Error
	require.NoError(t, err)

	return perm
}

// CreateAdminUserForTesting creates a complete admin user setup including session
// This is a convenience function that creates both the user group and session
func CreateAdminUserForTesting(t *testing.T, db *sqldb.Database, username string) string {
	// Create admin user group
	userGroup := CreateTestAuthUserGroup(t, db, "test-admin-group", true)

	// Create session with admin privileges
	sessionID := CreateTestSession(t, db, username, true)

	// Encode user group info in session provider data
	var providerData map[string]interface{}
	err := json.Unmarshal(
		[]byte(`{"user_groups":["`+userGroup.Name+`"],"site_admin":true}`),
		&providerData,
	)
	require.NoError(t, err)

	encodedData := sqldb.EncodeBlob(providerData)
	err = db.DB.Model(&sqldb.SessionDB{}).
		Where("id = ?", sessionID).
		Update("provider_source_auth", encodedData).Error
	require.NoError(t, err)

	return sessionID
}

// CreateRegularUserForTesting creates a complete regular user setup including session
func CreateRegularUserForTesting(t *testing.T, db *sqldb.Database, username string) string {
	// Create regular user group (not site admin)
	userGroup := CreateTestAuthUserGroup(t, db, "test-user-group", false)

	// Create session without admin privileges
	sessionID := CreateTestSession(t, db, username, false)

	// Encode user group info in session provider data
	var providerData map[string]interface{}
	err := json.Unmarshal(
		[]byte(`{"user_groups":["`+userGroup.Name+`"],"site_admin":false}`),
		&providerData,
	)
	require.NoError(t, err)

	encodedData := sqldb.EncodeBlob(providerData)
	err = db.DB.Model(&sqldb.SessionDB{}).
		Where("id = ?", sessionID).
		Update("provider_source_auth", encodedData).Error
	require.NoError(t, err)

	return sessionID
}

// CreateTestContainerWithAuth creates a test container with authentication dependencies
// This is useful for tests that need to create handlers with auth dependencies
func CreateTestContainerWithAuth(t *testing.T, db *sqldb.Database) *container.Container {
	return CreateTestContainer(t, db)
}

// CreateTestCreateSessionCommand creates a CreateSessionCommand for testing
func CreateTestCreateSessionCommand(t *testing.T, db *sqldb.Database) *auth.CreateSessionCommand {
	cookieSessionService, _ := CreateTestCookieSessionService(t, db)
	return auth.NewCreateSessionCommand(cookieSessionService)
}
